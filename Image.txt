// GLSL STARTER CODE BY DANIEL S. BUCKSTEIN

struct sRectangle
{
 	vec2 pos;
    float width;
    float height;
};
    
void initRectangle(out sRectangle rectangle, in vec2 pos, in float width, in float height)
{
    rectangle.pos = pos;
    rectangle.width = width;
    rectangle.height = height;
}
    
bool inRectangle(in vec2 pixelCoord, in sRectangle rectangle)
{
	if ((pixelCoord.x > rectangle.pos.x - rectangle.width) &&
        (pixelCoord.x < rectangle.pos.x + rectangle.width) &&
        (pixelCoord.y > rectangle.pos.y - rectangle.height) &&
        (pixelCoord.y < rectangle.pos.y + rectangle.height)) 
    {
		return true;
	}
    
	return false;
}

vec4 calcColor(in sViewport vp, in sRay ray)
{
    vec4 color = texture(iChannel0, vp.uv);
    
    // Border walls
    sRectangle rLWallTop;
    initRectangle(rLWallTop,    vec2(0.02, 0.77), 0.02, 0.23);
    
    sRectangle rLWallBotton;
    initRectangle(rLWallBotton, vec2(0.02, 0.23), 0.02, 0.23);
    
    sRectangle rRWallTop;
    initRectangle(rRWallTop,    vec2(0.98, 0.77), 0.02, 0.23);
    
    sRectangle rRWallBotton;
    initRectangle(rRWallBotton, vec2(0.98, 0.23), 0.02, 0.23);
    
    sRectangle rTWall;
    initRectangle(rTWall,       vec2(0.50, 0.97), 1.00, 0.03);
    
    sRectangle rBWall;
    initRectangle(rBWall,       vec2(0.50, 0.03), 1.00, 0.03);
    
    // Inner walls
    sRectangle rIWall1;
    initRectangle(rIWall1,  vec2(0.1, 0.58), 0.02, 0.44);
    
    sRectangle rIWall2;
    initRectangle(rIWall2,  vec2(0.16, 0.17), 0.04, 0.03);
    
    sRectangle rIWall3;
    initRectangle(rIWall3,  vec2(0.18, 0.3), 0.02, 0.1);
    
    sRectangle rIWall4;
    initRectangle(rIWall4,  vec2(0.18, 0.68), 0.02, 0.2);
    
    sRectangle rIWall5;
    initRectangle(rIWall5,  vec2(0.45, 0.85), 0.25, 0.03);
    
    sRectangle rIWall6;
    initRectangle(rIWall6,  vec2(0.83, 0.85), 0.08, 0.03);
    
    sRectangle rIWall7;
    initRectangle(rIWall7,  vec2(0.89, 0.7), 0.02, 0.16);
    
    sRectangle rIWall8;
    initRectangle(rIWall8,  vec2(0.8, 0.57), 0.16, 0.03);
    
    sRectangle rIWall9;
    initRectangle(rIWall9,  vec2(0.54, 0.71), 0.29, 0.03);
    
    sRectangle rIWall10;
    initRectangle(rIWall10, vec2(0.66, 0.63), 0.02, 0.09);
    
    sRectangle rIWall11;
    initRectangle(rIWall11, vec2(0.69, 0.44), 0.36, 0.03);
    
    sRectangle rIWall12;
    initRectangle(rIWall12, vec2(0.26, 0.44), 0.02, 0.3);
    
    sRectangle rIWall13;
    initRectangle(rIWall13, vec2(0.69, 0.57), 0.36, 0.03);
    
    sRectangle rIWall14;
    initRectangle(rIWall14, vec2(0.6, 0.17), 0.32, 0.03);
    
    sRectangle rIWall15;
    initRectangle(rIWall15, vec2(0.45, 0.76), 0.02, 0.08);
    
    sRectangle rIWall16;
    initRectangle(rIWall16, vec2(0.6, 0.3), 0.32, 0.03);
    
	// List of all walls
    sRectangle[] sRectangles = sRectangle[] (rLWallTop, rLWallBotton, rRWallTop, rRWallBotton, rTWall, rBWall,
                                            rIWall1, rIWall2, rIWall3, rIWall4, rIWall5, rIWall6, rIWall7,
                                            rIWall8, rIWall9, rIWall10, rIWall11, rIWall12, rIWall13, rIWall14,
                                            rIWall15, rIWall16);
    
    // checks if pixel is in any rectanle
    for(int i = 0; i < sRectangles.length(); i++)
    {
        if(inRectangle(vp.uv, sRectangles[i]))
        {
            if(i - 5 == -6)
            {
                color = vec4(1.0, 0.0, 0.0, 1.0);
                break;
            }
            
            //return vec4(0.0);
            color = vec4(0.7, 0.3, 0.0, 1.0);
            break;
        }
    }
    
    vec3 normal = vec3(0, 0, 1);
    
    vec3 lightPos = vec3(0.02 * iResolution.x, 0.5 * iResolution.y, 1.5);
    
    if(iMouse.z > 0.0) // sets light pos to start if not clicking
    	lightPos = vec3(iMouse.x, iMouse.y, 1.5);
    
    vec3 L; // Light vector
    float Kd; // Diffuse coefficient
    float Il; // Intensity
    float d; // Distance
    float Il2; // Attenuated intensity
    float Id; // Diffuse intensity
    
    L = normalize(lightPos - vec3(vp.pixelCoord, 0.0));
    Kd = max(0.0, dot(normal, L));
    
    Il = 1.0;
    d = distance(lightPos, vec3(vp.pixelCoord, 0.0));
    Il2 = 1.0 / (1.0 + d / Il) * (1.0 + d / Il);
    
    Id = Kd * Il2;
    
    return color * vec4(1.0, 1.0, 1.0, 1.0) * Id;
    
}

void mainImage( out vec4 fragColor, in vec2 fragCoord )
{
   // viewing plane (viewport) inputs
    const sBasis eyePosition = sBasis(0.0);
    const sScalar viewportHeight = 2.0, focalLength = 1.5;
    
    // viewport info
    sViewport vp;

    // ray
    sRay ray;
    
    // render
    initViewport(vp, viewportHeight, focalLength, fragCoord, iResolution.xy);
    initRayPersp(ray, eyePosition, vp.viewportPoint.xyz);

    // Output to screen
    fragColor = calcColor(vp, ray);
}